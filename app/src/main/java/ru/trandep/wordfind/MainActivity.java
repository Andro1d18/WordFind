package ru.trandep.wordfind;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.os.HandlerThread;import android.support.v7.app.ActionBarActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SurfaceHolder;import android.view.SurfaceView;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Random;//27.01.2016 остановился на том, что смог опредил координаты textView2 (от левого верхнего до правого нижнего) следующий шаг определить каждую букву// в своё textView со своим id, затем ПЛАНИРОВАЛ СДЕЛАТЬ при помощи объекта MotionEvent считывать координаты по которым провели палец и анализиовать// по каким textView провели и таким образом собирать слова/*План работ на 30.01:1. реализовать распределение  поля букв в свои ячейки с id: у каждой буквы должен быть свой id вью элемента, чтобы потом к ней можно было обращаться и узнавать координаты2. реализовать алгоритм выделение слов (описан ниже)(если успею) 3. реализовать алгорит зачеркивания слов(если успею) 4. реализовать алгоритм прохождения уровня.алгоритм выделения слов:1. Листенер слушает коориданты (его особенность в том, что он слушает внутри View-элемента) и выдаёт начальную точку и конечную2. Определенный метод проиизводит сверху кооридинат линии касания с ячейками, в которых буквы (пока принцип такой: у всех букв заранее известны координаты букв относительно не всего экрана, а относительно их view(так как listener сообщает координаты внутри view)), на выходе возвращая  массив букв3. Если такое слово есть, то слово зачеркивается (передает в метод зачеркивания координаты/ячейки зачеркивания) и сереют. Если нет то нетИтог работ 30.01.:недоделал 1ый пункт. Остановился на том, что получилось сделать грид, заполняемый строчками. Теперь нужно понять как сделать заполнение не строчками, а буквами.Итог работ 03.02:Приостановил работу с Grid (разделение на колонки) для поиска решения обращаться к каждому элементу по idПонял, что можно обратиться к id через обращение к объекту TextView, но не смог получить список объектов TextView. Попробовал сделать для этого переменную list,хранящую элементы TextView, но по всей видимости они не заполнялись и выходила ошибка NullPointer. Затем решил скопировать приложение кошковода чтобы понять как онпо ID обращается к элементам. Остановился на первом запуске его приложение - выходит ошибка. Нужно попробовать запустить с try catch*/public class MainActivity extends ActionBarActivity implements  SurfaceHolder.Callback{    IdentifyCoordsAllTextViewFromMainView identCoordAllTextView ;    private SurfaceView mSurface;    public Painter mThread;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mSurface = (SurfaceView) findViewById(R.id. surface);        mSurface.getHolder().addCallback(this);        //создаём новый экземляр класса        WordsField wordsTest = new WordsField();        //находим текствью        TextView tv = (TextView) findViewById(R.id.textView2);        //выводим массив на экран        tv.setText(wordsTest.outToDisplay);    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }    // Переопределяем методы работы с Surface    @Override    public void surfaceCreated(SurfaceHolder holder) {        mThread = new Painter(holder);        mThread.start();//        // Рисуем график на SurfaceView//        mThread.draw();        //TODO есть закольцованность между получением FL для создания тачЛистенера который потом цепляется к LL        //Прикрепляем ТачЛистенер        LinearLayout mainLL = (LinearLayout) findViewById(R.id.mainLL);        IdentifyCoordsAllTextViewFromMainView identCoordAllTextView = new IdentifyCoordsAllTextViewFromMainView ((ViewGroup) findViewById(R.id.mainFL));        MyTouchListener myTouchListener = new MyTouchListener(identCoordAllTextView, mThread);        mainLL.setOnTouchListener(myTouchListener);    }    @Override    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {        // Не используем изменение картинки    }    @Override    public void surfaceDestroyed(SurfaceHolder holder) {        // Очищаем поток        mThread.quit();        mThread = null;    }    // Класс для работы с изображением в отдельном потоке    public class Painter extends HandlerThread {        // Свойства класса        private SurfaceHolder mDrawingSurface;        Paint p = new Paint();        Painter(SurfaceHolder holder) {            super("Painter");            mDrawingSurface = holder;        }        //Нарисовать линию между предпоследний и последней точками из TouchListener - подаётся список Point        public void draw(ArrayList<ru.trandep.wordfind.MyTouchListener.Point> listPoints){            //развёртка listPointer - достать координаты            int count = listPoints.size();            float xStart = listPoints.get(count-2).x;            float yStart = listPoints.get(count-2).y;            float xEnd = listPoints.get(count-1).x;            float yEnd = listPoints.get(count-1).y;            //достать и заблокировать канву            Canvas c = mDrawingSurface.lockCanvas();            //Нарисовать линию            drawLine(c, xStart, yStart, xEnd, yEnd);            //разблокировать канву            mDrawingSurface.unlockCanvasAndPost(c);        }        //рисует точку        //TODO в будущем это нужно будет вообще? Скорее всего нет        public void draw(float x, float y){            Canvas c = mDrawingSurface.lockCanvas();            p.setColor(Color.BLUE);            // толщина линии = 3            p.setStrokeWidth(3);            c.drawPoint(x,y,p);            mDrawingSurface.unlockCanvasAndPost(c);        }        //рисуем линию        private void drawLine (Canvas c, float xStart, float yStart, float xEnd, float yEnd){            p.setColor(Color.RED);            p.setStrokeWidth(5);            c.drawLine(xStart, yStart, xEnd, yEnd, p);        }        //дропаем линию        private void wipeDrawLine(Canvas c, float xStart, float yStart, float xEnd, float yEnd){            p.setColor(Color.BLACK);            p.setStrokeWidth(5);            c.drawLine(xStart, yStart, xEnd, yEnd, p);        }        //Сбросить всю, только что нарисованную, линию (при отпускании пальца)        public void wipeLine(ArrayList<ru.trandep.wordfind.MyTouchListener.Point> listPoints){            Canvas c = mDrawingSurface.lockCanvas();            //развёртка listPointer - достать координаты            int count = listPoints.size();            //идём по всему списку, достаём первую точку и следующую за ней и между ними рисуем линию цвета фона - таким образом проходим по всем Point списка.            for (int i = 1; i < count; i++) {                float xStart = listPoints.get(i-1).x;                float yStart = listPoints.get(i-1).y;                float xEnd = listPoints.get(i).x;                float yEnd = listPoints.get(i).y;                wipeDrawLine(c, xStart, yStart, xEnd, yEnd);            }            mDrawingSurface.unlockCanvasAndPost(c);        }        //Нарисовать complitedLine - итоговая красивая, прямая, прошедшая проверку линия        public void complitedLine(ArrayList<TextView> listDynamicTextViewTouched){            //получить канву и заблокировать            Canvas c = mDrawingSurface.lockCanvas();            //достать центральные координаты первогои последнего затаченных textview            int count = listDynamicTextViewTouched.size();            float xStart = listDynamicTextViewTouched.get(0).getX() + (listDynamicTextViewTouched.get(0).getWidth()/2);            float yStart = listDynamicTextViewTouched.get(0).getY() + (listDynamicTextViewTouched.get(0).getHeight()/2);            float xEnd = listDynamicTextViewTouched.get(count-1).getX() + (listDynamicTextViewTouched.get(0).getWidth() /2);            float yEnd = listDynamicTextViewTouched.get(count-1).getY() + (listDynamicTextViewTouched.get(0).getHeight() /2);            //нарисовать линию            drawLine(c, xStart, yStart,xEnd,yEnd);            //разблокировать канву            mDrawingSurface.unlockCanvasAndPost(c);        }    }    //на 17.01.2016 запуск программы натравлен на жмаканье по TextView    public void onClick(View view) {        //IdentifyCoordsAllTextViewFromMainView identCoordAllTextView2 = new IdentifyCoordsAllTextViewFromMainView ((ViewGroup) findViewById(R.id.mainFL));       // identCoordAllTextView = identCoordAllTextView2;        IdentifyCoordsAllTextViewFromMainView identCoordAllTextViewFromClick = new IdentifyCoordsAllTextViewFromMainView ((ViewGroup) findViewById(R.id.mainFL));        identCoordAllTextView = identCoordAllTextViewFromClick; //нужно чтобы объект identCoordAllTextView работал в других частях программы        //создаём новый экземляр класса        WordsField wordsTestClick = new WordsField();        //находим текствью        TextView tv = (TextView) findViewById(R.id.textView2);        //выводим массив на экран        tv.setText(wordsTestClick.outToDisplay);//        //блок для вывода координат textView2 - для понимания как работает определение координат//        String sTest = "";//        int[] coordsView = new int[6];//        //узнаем начальные координаты tv и записываем на 0 и 1 места в массиве//        tv.getLocationInWindow(coordsView);//////        //на 2 и 3 место в массиве записываем конечные координаты//        coordsView [2] = coordsView [0] + tv.getWidth();//        coordsView [3] = coordsView [1] + tv.getHeight();//        //блок вывода на экран путем присвоении стинговой переменной всех элементов массива затем присвоение значение этой стринговой переменной в текствью//        for (int i = 0; i < coordsView.length; i++) {//            sTest = sTest + coordsView[i] + " _ ";//        }//        TextView tv2 = (TextView) findViewById(R.id.textView3);//        tv2.setText(sTest);        TextView tv3 = (TextView) findViewById(R.id.textView4);        //создан для тестирования касания       // rl.getChildAt();        //Попытка настройки адаптера       // GridView gridView = (GridView) findViewById(R.id.gridView);        //gridView.setAdapter(new WordGridAdapter(this, wordsTest.rowLetters));      //  WordGridAdapter wordAdapter = new WordGridAdapter(this, wordsTest.rowLetters);     //   gridView.setAdapter(wordAdapter);        //попытка извлеч координаты одного элемента грида    //    int countGridElement = 0;//        countGridElement = wordAdapter.viewList.size();        TextView tvTest = (TextView) findViewById(R.id.testView);       // tvTest.setText(" " + countGridElement);        //tvTest.setText(" " + identCoordAllTextView.getIdTextViewByCoords(220, 836));        //17.02.2016 ЗАКОНЧИЛ ТУТ - НУЖНО РАЗОБРАТЬСЯ КАКИЕ КООРДИНАТЫ ОПРЕДЕЛИЛИСЬ!!!!        //18.02.2016 определ что координаты квадрантов описываются правильно! Определял через добавление листенера тача к View mainLL -        // листенер слушает координаты внутри view (начальная точка отсчета не левый верхний край экрана, а левыый верхний край View)        // ну и координаты квадранта такие же (проверил только по X)        //НА СЛЕУЮЩИЙ КОДИНГ - проверь координату по Y и если норм, то накручивай определение ID TV по которым был тач, и нарисовку линии!        //На 22.02.16 сделано: проверена координата Y - всё определяется корректно. Метод определения TV по ID работает,но он не даёт нужного результата. Разработан        //дополнительный метод, который определяет ТЕКС у TextView по Координатам!        // на следующий кодинг -        // 1). научится опеделять всё слово, по которому провели. Научится записывать каждый тач в список (получается список списков) - ГОТОВО        // 2). Если ТАЧ был не коорректный, то принимать соответствующие меры, к примеру:        //  а. сделать чтобы не выдавалась ошибка если листенер ушёл за рамки FrameLayout (на данный момент возникает ошибка        // (PS НЕ ЗАБУДЬ ЧТО ПРОВЕРКА РАБОТАЕТ ПО ДОЛБАНУТОМУ - ТОЛЬКО КОГДА ТЫКАЕШЬ НА ПОЛЕ С БУКВАМИ (потому что всё завязано на onClick)))        //  б. научится определять не правильное выделение букв - (буквой Г, или под 30 градусов)        //        // 3). нарисовать линию по координатам.        //2ой заход 22.02.16: час думал над тем, как сделать независимым класс identCoordAllTextView - например, чтобы он реагировал на события в другой части программы        // и выполнялся параллельно. В теории это возможно, но нужно долго изучать. Пока решил сделать через листенер в основном классе программы.        // остановился на 1 пункте (создал fillinglistDynamicTextViewTouched Но не проверил РАБОТАЕТ ЛИ - остановился на проверке (нужно рефакторить потому что        //объект identCoordAllTextView создётся в onClick! Нужно придумать чтото с этим.        //ПО ПЕРВОМУ пункту всё работает всё ОК!!!        //24.02. закончил на выводе списков текст вью! Дублируется! испарвь ошибку        //        //27.02 - сделал корректный список списков тачей! и понял как переопределять некоторые методы в высокоуровневых классах        //Для этого протестировал и сейчас рисуются линии. Также для теста создал кнопку - на которой нарисован круг! Круто!!        //Что сейчас - 1. сейчас через Петов сюрфейс накрутить перерисовку фрейм лайоута, коррдинаты брать из листенера        //2. затем нужно а и б из пункта №2        //3. затем нужно всё сделать красиво и отдать пету        //План:        //Класс1 - Painter :        // метод1 - lifeLine - рисование текущего тача (рисуется в любом случае и удаляется тоже в любом случае)        //        // метод2 - complitedLine - нарисовать проверенную на корректность линию (удаляем lifeline и если корректно то рисуем complitedLine)        // метод3 - wipeLine - стереть линию (стерание на самом деле - нарисовать линию пустым цветом)        //        // Класс2 - PointSequence (последовательость точек)        // метод1 - createNew   (это listDynamicTextViewTouched только его нужно создать у другого класса - у нового PointSequence) + создаётся список всех точек        // метод2 - checkCorrect проверка корректности (статический метод - возвращает true если прошла проверку)        // свойство - список проводок(тачей)  (добавляем listlistToched в класс PointSequence)        //        //        //ИТОГ 07.03.2016 - остановился на ComplitedLine - рисуется криво! Исправь!        // общий итог: сделал вайплайн и лайфлайн(её нужно только переназвать), сейчас делаем комплитедлайн и потом накручиваем проверку и всё готово!    }    //Весь блок ниже нужен только для того чтобы протестировать MotionEvent. На 27.01.2016 только скопировал, но ниразу не тестировал//    float x;//    float y;//    String sDown;//    String sMove;//    String sUp;//    @Override//    public boolean onTouch(View v, MotionEvent event) {//        x = event.getX();//        y = event.getY();////        switch (event.getAction()) {//            case MotionEvent.ACTION_DOWN: // нажатие//                identCoordAllTextView.listDynamicTextViewTouched.clear();//                break;////            case MotionEvent.ACTION_MOVE: // движение//                //заполнение списка  текст вью по которым провели//                identCoordAllTextView.fillinglistDynamicTextViewTouched(x,y);//                // Рисуем график на SurfaceView//                mThread.draw(x,y);//                break;////            case MotionEvent.ACTION_UP: // отпускание//            case MotionEvent.ACTION_CANCEL://                //создание дублированной переменной списка динамик текстВью (по которым провели только что),//                // чтобы в список списков добавлился новый список, а не ссылка на listDynamicTextViewTouched//                // (если будет добавляться ссылка, то список списков будет содержать всегда один и тот же список тачей)//                ArrayList<TextView> oneTouched = new ArrayList<>();//                for (TextView tvOneTouched: identCoordAllTextView.listDynamicTextViewTouched){//                    oneTouched.add(tvOneTouched);//                }//               //добавляем в список списков наш только что созданный список//                identCoordAllTextView.listListsTouch.add(oneTouched);//                break;//        }////        return true;//    }    //Тест с кнопкой    public void myBut(View view) {        MyButton but = (MyButton) findViewById(R.id.button);        int i = Integer.parseInt(but.getText().toString().trim());        i++;        but.setText(String.valueOf(i));    }//запаска - рисовалка квадрата//        private void drawColumn(Canvas c, float left, float top, float width, float height){//            // автовычисляемые поля//            float rightMargin = left + width;//            float bottomMargin = top + height;//            //задаём цвет линии//            p.setColor(Color.RED);//            // толщина линии = 10//            p.setStrokeWidth(3);//            // рисуем прямоугольник//            c.drawRect(left, top, rightMargin, bottomMargin, p);//        }    // Класс ПолеСлов    public class WordsField {        String [][] words;  //Главная переменная - двумерный массив для букв        String outToDisplay = ""; //переменная, используемая для вывода двумерного массива на экран        ArrayList<String> listWords = new ArrayList<String>(); //БазаДанных слов для тестирования TODO убрать это в будущем        ArrayList<String> bigNotLogicalListWords = new ArrayList<String>(); //Список  слов для тестирования на большом числе слов TODO убрать это в будущем        int countRows = 10;  //для тестирования фиксированное число строк TODO в будущем вводить по умному (анализ разрешения экрана+диагональ устройства)        int countColumns = 10;//для тестирования фиксированное число строк TODO в будущем вводить по умному (анализ разрешения экрана+диагональ устройства)        List<String> rowLetters = new ArrayList<>(); //Список Строк букв из сетки - нужна для вывода в grid        String tempRowLetters = ""; //темповая переменная - нужна для формирования rowLetters        //конструктор класса. На данный момент в конструкторе класса вызывается метод заполнения поля словами        WordsField (){            Collections.addAll(this.listWords, "зов", "арка", "стол", "брак", "изба", "скала", "ролик", "мусор"); //заполнение базы данных словами для примера            Collections.addAll(this.bigNotLogicalListWords, "зов", "арка", "стол", "брак", "изба", "скала", "ролик", "мусор", "протон", "электрон"                    , "пурга", "лифт", "фитиль", "класс", "мука", "мыло", "тесть", "свекла", "мембрана","водка", "вода", "ветер", "ель", "метель",                    "трактор", "природа", "дар", "нефть", "кредит"); //заполнение базы данных словами для примера            Random random = new Random();            //создать двумерный массив размерами [countRows][countColumns]            this.words = new String [countRows][countColumns];            //вызываем метод заполнения массива words словами            fillingWordsField(this.words);            //Алгоритм записи всех элементов массива words в переменную outToDisplay. Затем эта переменная просто выводится на экран (пока для теста)            for (int i = 0; i < countRows; i++) {                for (int j = 0; j < countColumns; j++) {                    if (words[i][j] == null) words[i][j]= "7";  //если пустой элемент массива, то пишем "о" (для удобства различать при тестировании                    outToDisplay = outToDisplay + words[i][j] + " ";                    tempRowLetters = tempRowLetters + words[i][j];                }                this.rowLetters.add (tempRowLetters);//нужно ТОЛЬКО для тестирование Адаптера                tempRowLetters = ""; //обнуление темповой переменной, чтобы правильно заполнять список rowLetters                outToDisplay = outToDisplay + "\n";            }        }        //Начальный метод заполняющий поле словами (метод посылает слова для заполнения в метод writeWordOnField        public void fillingWordsField(String [][] words){            for (int i = 0; i < bigNotLogicalListWords.size(); i++) {                //записываем в s первое слово из базы данных для тестирования                String s = bigNotLogicalListWords.get(i);                //переводим слово в массив символов                char[] letter = s.toCharArray();//            //вызываем функцию написания букв в двумерный массив. в качестве аргумента подаём массив символов//            writeWordOnField(letter);.                //Предпринимаем 5 попыток вставить слово - пытаемся 5 раз встравить слово в 5 разных наборов рандомных координат                for (int j = 0; j < 5; j++) {                    //рандомно определили стартовые координаты и направление (уже такие чтобы слово не вышло за границы)                    int[] startPointAndDirection = randomStartPointAndDirection(letter);                    int rowStart = startPointAndDirection[0]; //x                    int colStart = startPointAndDirection[1]; //y                    int direction = startPointAndDirection[2]; //направление                    //чекаем можно ли вставить в эти координаты (на предмет не помешаем ли мы уже существующему слову)                    if (checkNotDelete(colStart, rowStart, letter, direction)) {                        writeWordOnField(colStart, rowStart, letter, direction);                        break; //как только прошла проверка и получилось вставить слово брекаем цикл for                    }                }            }        }        //булевый Метод позволяющий определить можно ли в данных координатах и с таким направление начинать писать слово,        // чтобы он не потёр уже написанное слово, причем если буквы в месте пересечения совпадает - метод такое пропустит        /*TODO добавить проверку чтобы не заезжало одно слово на другое более чем на 1 букву (например слова СКАЛА и АРКА не должны заканчиваться и начинаться с одной буквы если идут в одну линию, а если идут перпендикулярно то можно)*/        public boolean checkNotDelete(int colStart, int rowStart, char[] letter, int direction){            boolean ret = false;            switch (direction) {                case 0://слева направо                    for (int i = 0; i < letter.length; i++){                        if (words[rowStart][colStart + i] == null)                            ret = true;                        else if (words[rowStart][colStart + i].equals(Character.toString(letter[i])))                            ret = true;                        else {                            ret = false;                            break;                        }                    }                    break;                case 1: //сверху вниз                    for (int i = 0; i < letter.length; i++){                        if (words[rowStart + i][colStart] == null)                            ret = true;                        else if (words[rowStart + i][colStart].equals(Character.toString(letter[i])))                            ret = true;                        else {                            ret = false;                            break;                        }                    }                    break;                case 2: //справа налево                    for (int i = 0; i < letter.length; i++) {                        if (words[rowStart][colStart - i] == null)                            ret = true;                        else if (words[rowStart][colStart - i].equals(Character.toString(letter[i])))                            ret = true;                        else {                            ret = false;                            break;                        }                    }                    break;                case 3: //снизу вверх                    for (int i = 0; i < letter.length; i++){                        if (words[rowStart - i][colStart] == null)                            ret = true;                        else if (words[rowStart - i][colStart].equals(Character.toString(letter[i])))                            ret = true;                        else {                            ret = false;                            break;                        }                    }                    break;            }            return ret;        }        //В метод подаётся слово, а он возвращает РАНДОМНЫЕ коррдинаты начальной точки и направление, при которых слово не выйдет за границы поля        public int[] randomStartPointAndDirection (char[] letter){            //создаём массив, в котором будут коррдинаты начальной точки и направление.            int[] startPointAndDirection = new int[3];            //рандомно определеяем напавление и написываем на последнее место в массиве:            Random random = new Random();            startPointAndDirection[2] = random.nextInt(4);            //после того как определили направление рандомно определяем стартовую точку, таким образом чтобы слово вместилось в сетку            switch (startPointAndDirection[2]) {                case 0: //слева направо                    startPointAndDirection[0] = random.nextInt(this.countRows);                    startPointAndDirection[1] = random.nextInt(this.countColumns - letter.length + 1);                    break;                case 1: //сверху вниз                    startPointAndDirection[0] = random.nextInt(this.countRows - letter.length + 1);                    startPointAndDirection[1] = random.nextInt(this.countColumns);                    break;                case 2: //справа налево                    startPointAndDirection[0] = random.nextInt(this.countRows);                    startPointAndDirection[1] = this.countColumns - (random.nextInt(this.countColumns - letter.length + 1)) - 1;                    break;                case 3: //снизу вверх                    startPointAndDirection[0] = this.countRows - random.nextInt(this.countRows - letter.length + 1) - 1;                    startPointAndDirection[1] = random.nextInt(this.countColumns);                    break;            }            return startPointAndDirection;        }        //(нужен был для первоначального тестирования) Метод, печатающий 1 слово(каждая буква в отдельном элемменте массива) в рандомном направлении        public void writeWordOnField(char[] letter){            //определяем в какую сторону будем писать            Random random = new Random();            int roll = random.nextInt(4);            int row;            int col;            switch (roll){                case 0: //слева направо                    row = random.nextInt(this.countRows);                    col = random.nextInt(this.countColumns - letter.length+1);                    for (int i = 0; i <letter.length; i++) {                        words[row][col+i] = Character.toString(letter[i]);                    }                    break;                case 1: //сверху вниз                    row = random.nextInt(this.countRows - letter.length+1);                    col = random.nextInt(this.countColumns);                    for (int i = 0; i < letter.length ; i++) {                        words[row + i][col] = Character.toString(letter[i]);                    }                    break;                case 2: //справа налево                    row = random.nextInt(this.countRows);                    col = this.countColumns - (random.nextInt(this.countColumns - letter.length+1)) - 1;                    for (int i = 0; i <letter.length; i++) {                        words[row][col-i] = Character.toString(letter[i]);                    }                    break;                case 3: //снизу вверх                    row = this.countRows - random.nextInt(this.countRows - letter.length+1) - 1;                    col = random.nextInt(this.countColumns);                    for (int i = 0; i < letter.length ; i++) {                        words[row - i][col] = Character.toString(letter[i]);                    }                    break;                case 4:                    break;                case 5:                    break;                case 6:                    break;                case 7:                    break;            }        }        // Метод получает слово, стартовые координаты и направление, и вписывает слово (пока в четырех направлениях)        public void writeWordOnField(int colStart, int rowStart, char[] letter, int direction){            switch (direction){                case 0://слева направо                    for (int i = 0; i <letter.length; i++)                        words[rowStart][colStart+i] = Character.toString(letter[i]);                    break;                case 1: //сверху вниз                    for (int i = 0; i < letter.length ; i++)                        words[rowStart + i][colStart] = Character.toString(letter[i]);                    break;                case 2: //справа налево                    for (int i = 0; i <letter.length; i++) {                        words[rowStart][colStart-i] = Character.toString(letter[i]);                    }                    break;                case 3: //снизу вверх                    for (int i = 0; i < letter.length ; i++)                        words[rowStart - i][colStart] = Character.toString(letter[i]);                    break;            }        }    }}